name : Building and Deploying  container image to AWS ECR and ECS

on:

    push:
        branches: [ "main" ]
    pull_request:
        branches: [ "main" ]
permissions:
  id-token: write
  contents: read
  
env:
    aws_region: us-east-1
    AWS_ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_TO_ASSUME }}
    ECR_REPOSITORY: uat
    IMAGE_TAG: ${{ github.run_number }}
    TASK_DEFINITION: demo-task
    CLUSTER: staging-cluster
    SERVICE: demo-service
    CONTAINER_NAME: nginx
  
jobs:
    Build:
        runs-on: ubuntu-latest
        outputs:  # Define outputs for the Deploy job
          image-uri: ${{ steps.set-image.outputs.image-uri }}
        steps:
            - name: Checkout code from Repo
              uses: actions/checkout@v4

            - name: Configure AWS Credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}
                  aws-region: ${{ env.aws_region }}

            - name: Login to Amazon ECR
              uses: aws-actions/amazon-ecr-login@v2
              id: login-ecr
            - name: Install Trivy
              uses: aquasecurity/trivy-action@master
              with:
                  scan-type: fs
                  severity: HIGH,CRITICAL
                  exit-code: 0
                  format: table
                  ignore-unfixed: true
            - name: Build, Tag Image
              id: build-image
              run : |
                docker build -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }} .
                echo "::set-output name=image::${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
            - name: Scanning Image with Trivy
              uses: aquasecurity/trivy-action@master
              with:
                  image-ref: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
                  format: json
                  severity: HIGH,CRITICAL
                  output: trivy-report.json
                  exit-code: 0
                  ignore-unfixed: true
            - name: Push Image Tag to ECR
              run: |
                docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
            - name: Store image URI for Deploy job
              id: set-image
              run: |
                IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY}}:${{ env.IMAGE_TAG }}"
                  echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
            - name: Post Fix Suggestions on PR
              if: github.event_name == 'pull_request'
              uses: actions/github-script@v6
              with:
                  script: |
                    // Use require() to import Node.js modules
                    const fs = require('fs');
                    
                    try {
                      // Read file synchronously (use async methods if preferred)
                      const fsReport = JSON.parse(fs.readFileSync('trivy-fs-results.json', 'utf8'));
                      const imageReport = JSON.parse(fs.readFileSync('trivy-image-results.json', 'utf8'));
                      
                      const formatVulns = (vulns) => vulns.map(v => `
                        **Package:** ${v.PkgName} (${v.InstalledVersion})  
                        **CVE:** ${v.VulnerabilityID} (${v.Severity})  
                        **Fix Version:** ${v.FixedVersion || 'None'}  
                        **Advisory:** ${v.PrimaryURL || 'N/A'}
                      `).join('\n');
        
                      const fsVulns = fsReport.Results?.flatMap(r => r.Vulnerabilities || []);
                      const imageVulns = imageReport.Results?.flatMap(r => r.Vulnerabilities || []);
        
                      let comment = '## ðŸ” Trivy Security Report\n';
                      if (fsVulns.length > 0) comment += `### ðŸ“‚ Filesystem Vulnerabilities\n${formatVulns(fsVulns)}\n`;
                      if (imageVulns.length > 0) comment += `### ðŸ³ Docker Image Vulnerabilities\n${formatVulns(imageVulns)}\n`;
                      if (fsVulns.length + imageVulns.length === 0) comment += 'âœ… No critical/high vulnerabilities found.';
        
                      await github.rest.issues.createComment({
                        issue_number: context.issue.number,
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        body: comment
                      });
                    } catch (error) {
                      core.error('Failed to process Trivy results: ' + error.message);
                    }
                
    Deploy:
        runs-on: ubuntu-latest
        needs: Build  # Depends on Build job
        steps:
          - name: AWS Creds Config 
            uses: aws-actions/configure-aws-credentials@v4
            with:
              role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}
              aws-region: ${{ env.aws_region }}
          
          - name: Download current task definition
            run: |
              aws ecs describe-task-definition --task-definition ${{ env.TASK_DEFINITION }} --query taskDefinition > task-definition.json
          
          - name: Update task definition with new ECR image
            run: |
              jq --arg IMAGE_URI "${{ needs.Build.outputs.image-uri }}" '.containerDefinitions[0].image = $IMAGE_URI | 
              del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy, .deregisteredAt)' task-definition.json > register-task-definition.json
          
          - name: Register new task definition
            run: |
              aws ecs register-task-definition --cli-input-json file://register-task-definition.json
              echo "NEW_TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition ${{ env.TASK_DEFINITION }} --query 'taskDefinition.taskDefinitionArn' --output text)" >> $GITHUB_ENV
          
          - name: Update ECS service
            run: |
              aws ecs update-service --cluster ${{ env.CLUSTER }} --service ${{ env.SERVICE }} --task-definition ${{ env.TASK_DEFINITION }} --force-new-deployment